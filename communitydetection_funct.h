//This file contains all of the functionality to gather data for he Community Detection part of the project
//This CommunityDetection function will detect the edge with the greatest BetweennessCentrality and remove
//that edge from the graph. It will then generate the new edge matrices and matrices generated by the 
//Floyd-Warshall algorithm to generate a new graph. Then the diameter of that new graph will be calculated.
//All of this will be repeated 5 times. This will be done for both directed and undirected.
using namespace std;

void CommunityDetection(Graph g, bool DIRECTED);

void CommunityDetection(Graph g, bool DIRECTED)
{
  Graph Ug = g; //Calling Copy-Constructor to make an identical graph that will be used for the undirected community
  vector<int> maxEdges;
  vector<int> maxDiameter;
  
  vector<int> outBetweenness=vector<int>();
  vector<int> outDiameter=vector<int>();
  
  ofstream fout;
  
  for(int z=0; z<5; z++)
  {
    if(DIRECTED)
    {
      maxEdges=BetweennessCentrality(g, DIRECTED);  
      outBetweenness.push_back(g.Edges[maxEdges[0]].DirectedBetweenness);
      cout<<"Removing those Edges from the Graph"<<endl;
      for(int i=0; i<(int)maxEdges.size(); i++)
      {
        g.Edges.erase(g.Edges.begin()+maxEdges[i]-i);
      }
      
      //Update the number of edges because of the deleted edges
      g.numDirEdges=g.Edges.size();
      
      //Creating edge matrix for directed graph
      for(int i=0; i<g.numVertices; i++)
      {
        for(int j=0; j<g.numVertices; j++)
        {
          int found1=false;
          for(int k=0; k<g.numDirEdges; k++)
          {
            if(g.Edges[k].source==i&&g.Edges[k].target==j)
            {
              g.edge_matrix[i][j]=k;
              found1=true;
              break;
            }
          }
          if(!found1)
            g.edge_matrix[i][j]=-1;
        }
      }      
      
      FloydWarshall(g);
      
      cout<<"Finding the Diameter of the new graph:"<<endl;
      outDiameter.push_back(GraphDiameter(g, DIRECTED, true));
      cout<<"The Diameter is: "<<outDiameter.back()<<endl;
      
      ShortestPath(g);
    }
    else//if UNDIRECTED
    {
      maxEdges=BetweennessCentrality(Ug, DIRECTED);
      outBetweenness.push_back(Ug.Edges_Undirected[maxEdges[0]].UndirectedBetweenness);
      cout<<"Removing those Edges from the Graph"<<endl;
      for(int i=0; i<(int)maxEdges.size(); i++)
      {
        Ug.Edges_Undirected.erase(Ug.Edges_Undirected.begin()+maxEdges[i]-i);
      }
      
      Ug.numUndirEdges=g.Edges_Undirected.size();      
      
      //Creating edge matrix for undirected graph
      for(int i=0; i<Ug.numVertices; i++)
      {
        for(int j=0; j<Ug.numVertices; j++)
        {
          int found1=false;
          for(int k=0; k<Ug.numUndirEdges; k++)
          {
            if(Ug.Edges_Undirected[k].source==i&&Ug.Edges_Undirected[k].target==j)
            {
              Ug.undir_edge_matrix[i][j]=k;
              found1=true;
              break;
            }
          }
          if(!found1)
            Ug.undir_edge_matrix[i][j]=-1;
        }
      }  
      
      FloydWarshall(Ug);
      
      cout<<"Finding the Diameter of the new graph:"<<endl;
      outDiameter.push_back(GraphDiameter(Ug, DIRECTED, true));
      cout<<"The Diameter is: "<<outDiameter.back()<<endl;
      
      ShortestPath(Ug);      
    }
    
    //The following is independent of DIRECTED
    if(z!=4)//Don't execute at the last iteration
    {
      cout<<"\n\n---Beginning Iteration "<<z+1<<"---"<<endl;
      cout<<"Calculating the new Betweenness Centrality values:"<<endl;
    }    
  }
  
  //OUTPUTS
  cout<<"\n\n***RESULTS:***"<<endl;
  
  for(int x=0; x<5; x++)
  {
    cout<<"With the removal of the "<<(DIRECTED? "Directed":"Undirected")<<" Edge with the highest"
        <<" value of "<<outBetweenness[x]<<endl;
    cout<<"The Diameter of the new Graph was "<<outDiameter[x]<<endl;
  }
  
  if(DIRECTED)
  {
    fout.open("directedcommunity.txt");
    fout<<"DirectedBetweenness\t"<<"Diameter"<<endl;
    for(int o = 0; o<5; o++)
    {
      fout<<outBetweenness[o]<<"\t"<<outDiameter[o]<<endl;
    }
  }
  else
  {
    fout.open("undirectedcommunity.txt");
    fout<<"UndirectedBetweenness\t"<<"Diameter"<<endl;
    for(int o = 0; o<5; o++)
    {
      fout<<outBetweenness[o]<<"\t"<<outDiameter[o]<<endl;
    }
  } 
  fout.close();
  return;
}