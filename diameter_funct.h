//This file contains the code for the Graph Diameter function
using namespace std;

//Determines the longest shortest path between two vertices for a given graph.
//
//Requires Graph object which has already had all info regarding vertices,
//  edges, and weights read into it, and has had the lengths of the shortest
//  paths between each combination of vertices calculated using the
//  Floyd Warshall algorithm. Also requires a boolean variable stating whether 
//  the graph is directed.
//
//Displays the length of the longest shortest for the given graph to the screen.
//  Displays all pairs of vertices which have this shortest path length between
//  them to the screen.


int GraphDiameter(Graph& g, bool directed, bool community);

int GraphDiameter(Graph& g, bool directed, bool community)	//Input parameter is the matrix generated by the Floyd-Warshall algorithm
{
  int lspLength = 0;
  vector<Vertex> VertexPairs;   //Even indices are sources, odd is target
  
  if(directed)
  {
    for (int i = 0; i < g.numVertices; i++) 
    {  
      for (int j = 0; j < g.numVertices; j++) 
      {
        if (g.d[i][j] > lspLength)  //length of the Longest Shortest Path is initially zero
        {      
          VertexPairs.clear();    //VertexPairs.size()==0
          VertexPairs.push_back(g.Vertices[i]);  //sets of vertices on either end of the Longest Shortest Path
          VertexPairs.push_back(g.Vertices[j]);  
          lspLength = g.d[i][j];
        }
      else if (g.d[i][j] == lspLength)
        {
          VertexPairs.push_back(g.Vertices[i]);  //sets of vertices on either end of the Longest Shortest Path
          VertexPairs.push_back(g.Vertices[j]);
        }
      }
    }
  }
  else//if undirected
  {
    for (int i = 0; i < g.numVertices; i++) 
    {  
      for (int j = 0; j < g.numVertices; j++) 
      {
        if (g.Ud[i][j] > lspLength)  //length of the Longest Shortest Path is initially zero
        {      
          VertexPairs.clear();    //VertexPairs.size()==0
          VertexPairs.push_back(g.Vertices[i]);  //sets of vertices on either end of the Longest Shortest Path
          VertexPairs.push_back(g.Vertices[j]);  
          lspLength = g.Ud[i][j];
        }
        else if (g.Ud[i][j] == lspLength)
        {
          VertexPairs.push_back(g.Vertices[i]);  //sets of vertices on either end of the Longest Shortest Path
          VertexPairs.push_back(g.Vertices[j]);
        }
      }
    }
  }
    if(!community)
    {  
      cout<<"Longest Shortest Path: "<<lspLength<<endl;
      //----------------Below is a terniary operator for outputting the 's' if there is more than 1 pair
      cout<<"The "<<VertexPairs.size()/2<<" Vertex Pair"<<((int)VertexPairs.size()>2 ? "s " : " ")<<"with the Longest Shortest Path:\n";
      for(int z=0; z<(int)VertexPairs.size(); z++)
      {
        cout<< " ( "<<VertexPairs[z].name<<", ";
        z++;
        cout<<VertexPairs[z].name<<" )" << endl;
      }
      cout<<endl;
    }
  return lspLength;
}